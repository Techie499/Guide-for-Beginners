-- TIMESTAMP and TIMESTAMPTZ data types
-- ##########################
/*
	1. Allows to store both date and time together
	
	2.  timestamp		 timestamp without timezone.
		timestamptz		 timestamp with a timezone
	3.  timestamptz 	 timezone handling
 		
		-	Internally stored value is always in UTC
			(Universal Coordinated Time, traditionally known as Greenwich Mean Time, GMT).
			
		Adding a timestamptz
 		
		- An INPUT value that has an explicit time zone specified is converted to UTC
		using the appropriate offset for that time zone
		
		- If no time zone is stated in the input string, then it is assumed to be in the time zone
		indicated by the system's TimeZone parameter, and is converted to UTC using the offset for
		the timezone zone.
		
		output a timestamptz
		
		- When a timestamptz value is output, it is always converted from UTC to the current
		timezone zone, and displayed as local time in that zone.
		
*/

-- Create a table

CREATE TABLE table_time_tz (
ts TIMESTAMP,
tstz TIMESTAMPTZ
); 
-- Now lets set the timezone

INSERT INTO table_time_tz (ts, tstz) VALUES
('2020-02-22 10:10:10107', '2020-02-22 10:10:10-07')

select * from table_time_tz

-- Show current timezone
show timezone
-- Now insert a record
-- View the data

-- Now Insert a record
-- View the deta
-- Lets change the timezone
SET TIMEZONE 'America/New_York' ;
-- Lets put beck the origin•L time zone
SET TIMEZONZ 'America/New_York'

-- Current timestamp
SELECT CURRENT_TIMESTAMP;
-- Current time of the day
SELECT TIMEOFDAY()
-- Using timezone() function to convert time based on a time zone
SELECT timezone( 'Asia/Singapore' , '2020-01-01 00:00:00')


/*
-- UUID data type
1. UUID  Universal Unique Identifier
2. It is a 128-bit quantity generated by an algorithm that make it unique in the known universe using the same algorithm.
3. Example
40e6251d-b5c6-4896-987c-f30f3678f608
— 32 digits
— hexadecimal digits
— separated by hyphens

4.UUID is much much better than the SERIAL data type when it comes to 'uniquness' across systems as SERIAL data
type generates only unique values within a single database.
5. create a UUID data type in PostgreSQL, you need a third part UUID at orithms to generate UUIDs e.g. uuid-ossp
*/

--1. Enable third part UUID extensions first e.g.
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
--2. Lets generate a sample UUID value first
SELECT uuid_generate_v1();
"cde2bef6-3e50-11eb-92fb-3af9d35059d8"

SELECT uuid_generate_v4();

--3. Lets crate a sample table 'table_uuid'
CREATE TABLE table_uuid(
	product_id UUID DEFAULT uuid_generate_v1(),
	product_name VARCHAR (100) not null
);

-- 4. Lets insert some data
INSERT INTO table_uuid (product_name) VALUES ('AB111aaasdasda');
SELECT * FROM table_uuid;

--5. Lets change UUID default value
ALTER table table_uuid
ALTER COLUMN product_id
SET DEFAULT uuid_generate_v4();

-- 6. Lets insert some more data



--Array ata types
/*
1. Every data type has its own companion array type e.g.,
	- integer has an integer[] array type,
	- character has character [J array type
2. An array data type is named by appending square brackets ([]) to the data type name of the array elements.
	
	variable []
	
	phone TEXT []
	
	class_name VARCHAR[]
*/
	
--Lets create a sample table
CREATE TABLE table_array(
	id SERIAL,
	name varchar(100),
phone text[]--our array
);

--view the data
SELECT * FROM table_array

--insert some sample data

INSERT INTO table_array (name,phones)
VALUES ('Adam', ARRAY ['(801)-123-4567','(819)-555-2222']);

INSERT INTO table_array (name,phones)
VALUES ('Linda', ARRAY ['(201)-123-4567','(214)-222-3333']);

--query data

SELECT * FROM table_array

SELECT 
	name,
	phones [1]
FROM
	table_array;
	
SELECT 
	name
FROM
	table_array
WHERE
	phones [2]='(214)-222-3333';
	
--hstore data type

/*
1. hstore is a data type that store data into key-value pairs
2. The hstore module implements the hstore data type.
3. The keys and values are just text strings only.
*/
--1. Lets install hstore extensions fi rst
CREATE EXTENSION IF NOT EXISTS hstore;
--2. Lets create our sample table

CREATE TABLE table_hstore(
	book_id SERIAL PRIMARY KEY,
	title VARCHAR(100) NOT NULL,
	book_info hstore
);

INSERT INTO table_hstore (title , book_info) values
(
	'TITLE 1',
	'
		"publisher"=>"ABC publisher",
		"paper_cost"=>"10.00",
		"e_cost"=>"5.85"
	'
)

--3. Lets query our data
SELECT * FROM table_hstore;

--4. Lets query specific hstore value

-- ->operator

SELECT 
	book_info -> 'publisher' as "publisher",
	book_info -> 'e_cost' as "Electronic Cost"
FROM table_hstore;


/*
JSON data type

1. PostgreSQL has built—in support for JSON With a great range Of processing functions and operators,
and complete indexing support.

2.The JSON datatype is actually text under the hood, with a verification that the format is valid json
input... much like XML.

3. The JSONB implemented a binary version of the JSON datatype

4.The JSON datatype, being a text datatype, stores the data presentation exactly as it is sent to PostgreSQL,
including whitespace and indentation, and also multiple-keys when present 
(no processing at all is done on the content, only form validation).

5. The JSONB datatype is an advanced binary storage format with full processing, indexing and searching
capabilities, and as such pre-processes the JSON data to an internal format, which does include a single
value per key; and isn't sensible to extra whitespace or indentation.
*/

--1. Lets create our sample table
CREATE TABLE table_json(
	id SERIAL PRIMARY KEY,
	docs JSON
);

SELECT * FROM table_json;

--2. lets insert some data
INSERT INTO table_json (docs) VALUES
('[1,2,3,4,5,6]'),
('[2,3,4,5,6,7]'),
('{"key" : "value")');

--3. Lets search the data
SELECT docs FROM table_json;

--4. Search speci fic data in JSON column
SELECT * FROM table_json
WHERE docs @>'2';

ALTER TABLE table_json
ALTER COLUMN docs TYPE JSONB;

CREATE INDEX ON table_json USING GIN (docs->'Publisher' jsonb_path_ops);

books
	book_id serial primary
	title varchar
	docs JSONB
		publisher,
		is_top:Y


/*
- Network Address Data types

1.PostgreSQL offers data types to store IPv4, IPv6, and MAC addresses.

2. Network Address Types

Name		Storage			Notes
_____		________		______________________

cidr		7 or 19 bytes	IPv4 and IPv6 networks
inet		7 or 19 bytes	IPv4 and IPv6 hosts and networks
macaddr		6 bytes			MAC addresses
macaddr8	8 bytes			MAC addresses (EUI—64 format)

inet

It is better to use these types instead of plain text types to store network addresses,
because these types offer input error checking and specialized operators and functions

3.Special sorting mechanism
When sorting inet or cidr data types, IPv4 addresses will always sort before IPv6 addresses,
including IPv4 addresses encapsulated or mapped to IPv6 addresses

4.These types are bundled with indexing support and advanced functions and operator support.

*/
--1. Lets build a sample table with an IP address for IPv4 and IP' 6 network address type i.e.inet
CREATE TABLE table_netaddr (
	id SERIAL PRIMARY KEY,
	ip INET
);

--lets insert some data

INSERT INTO table_netaddr (ip) VALUES
('4.35.221.243'),
('4.152.207.126'),
('4.152.207.238'),
('4.249.111.162'),
('12.1.223.132'),
('12.8.192.60');

--3.lets view the data
SELECT * FROM table_netaddr;

--4. Lets analysze entries for /24 networks ip addresses
-- set_masklen function : set netmask lenght for inet value


SELECT 
	ip,
	set_masklen(ip,24) as inet_24
FROM table_netaddr;

-- 5. Lets convert inet to cidr type

SELECT 
	ip,
	set_masklen(ip,24) as inet_24,
	set_masklen(ip::cidr,24) as cidr_24
FROM table_netaddr;


-- 6. we can also analysze other network like /27, /28 too
SELECT 
	ip,
	set_masklen(ip,24) as inet_24,
	set_masklen(ip::cidr,24) as cidr_24,
	set_masklen(ip::cidr,27) as cidr_27,
	set_masklen(ip::cidr,28) as cidr_28
FROM table_netaddr;